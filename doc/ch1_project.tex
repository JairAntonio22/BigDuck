
\chapter{Project}

\section{Introduction}
\subsection{Purpose}
\paragraph{} This document describes the software developement process, 
technical documentation, and user manual, for the final project of the Compiler
Design course. Which consists on the design and implementation of a programming
language and a virtual machine.

\subsection{Scope}
\paragraph{} The programming language developed is specified to be a compiled
imperative, with support of modules and structured types. Additionaly it is
required to develop a virtual machine capable to execute the output code
generated by the compiler.

\newpage

\section{Software Requirements}
\subsection{Analysis}
\paragraph{} Based on the specifications and recomendations given by the
teachers, the following requirements were defined as necessary for the
successful development of this project.

\paragraph{Functional requirements}
\begin{enumerate}
    \item The programming language must aim to solve a domain specific problem.
    \item The compiler must support scoped and global variables.
    \item The compiler must support numeric data types.
    \item The compiler must support conditional statements.
    \item The compiler must support loop statements.
    \item The compiler must support modules.
    \item The compiler must support recursion.
    \item The compiler must support structured types.
    \item The compiler must report compile-time errors.
    \item The compiler must generate intermidiate code.
    \item The virtual machine must execute generated code.
    \item The virtual machine must manage program memory.
    \item The virtual machine report run-time errors.
\end{enumerate}

\paragraph{Non-Functional requirements}
\begin{enumerate}
    \item The language grammar must be non-ambiguous.
    \item The compiler shall use a scanner and parser generation tool.
    \item The compiler must be efficient in time and memory.
    \item The virtual machine must be efficient in time and memory.
\end{enumerate}

\newpage

\section{Software Developement Process}

\subsection{Developement Process Description}
\paragraph{} The project was developed throught weekly sprints, were each
sprint consisted in developing a major feature needed for the programming
language compilation or execution. It must be said that despite having an
suggested schedule, the reality is that the project went a little bit different
from this schedule. This is because some features were prioritize to be
implemented first.

\subsection{Weekly Log}

\begin{figure}[h]
    \centering
    \begin{tabular}{cp{3.5in}}
        \toprule
        \textbf{Date} & \textbf{Description}\\
        \midrule Sep 20 &
        Proposal Developement\\

        \midrule Sep 27 &
        Lexic and syntax analysis\\

        \midrule Oct  4 &
        Symbol table and sematic cube\\

        \midrule Oct 11 &
        Expressions compilation\\

        \midrule Oct 18 &
        Conditionals compilation\\

        \midrule Oct 25 &
        Loops compilation\\

        \midrule Nov  1 &
        Procedures compilation\\

        \midrule Nov  8 &
        Semantic analysis, memory layout, and virtual machine\\

        \midrule Nov 15 &
        Structured types compilation, and application specific code\\

        \bottomrule
    \end{tabular}
\end{figure}

\newpage

\subsection{Git Commitments}
\paragraph{Note} Not all commits are included in this table because some of
them are not directly related with the project (like \texttt{README.md},
\texttt{.gitignore} updates or documentation advacements).

\begin{figure}[H]
    \centering
    \begin{tabular}{cp{1.25in}p{2.5in}}
        \toprule
        \textbf{Date} & \textbf{Title} & \textbf{Observations}\\
        \midrule
        Sep 27 & First Commit &
        The work done throught the previous HWs were really useful to getting
        to know ANTLR and make easier the \newline developement.\\

        \midrule
        Sep 29 & Parser and Lexer working &
        It was necessary to make some changes on the grammar to make easier
        and more concise the implementation.\\

        \midrule
        Oct  5 & Advance in semantic analysis &
        The implementation of a symbol table can be somewhat easy if the
        concept of symbol is well defined.\\

        \midrule
        Oct  8 & Semantic for \newline variables &
        Despite having a symbol table it is necessary to have additional
        flags to keep track the context of variables in order to have
        correct identification of variables.\\

        \midrule
        Oct  9 & Semantic for \newline procedures and \newline arguments &
        Some changes in the syntax were done, since it was not clear enough for 
        the compiler and also for myself.\\

        \midrule
        Oct  9 & Variable and \newline expression semantic done &
        Despite having a symbol table it is necessary to have additional
        flags to keep track the context of variables in order to have
        correct identification of variables.\\

        \midrule
        Oct 14 & TAC generation &
        Three address code can be simple to be generated by hand, however to
        implement it has to be done carefully.\\

        \midrule
        Oct 16 & Bugs corrected &
        There were associativity problems, this was due that all performed
        actions were done one level deeper on the syntax tree generation, thus
        as seen in class the associativity was done right to left.\\

        \bottomrule
    \end{tabular}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{cp{1.25in}p{2.5in}}
        \toprule
        \textbf{Date} & \textbf{Title} & \textbf{Observations}\\
        \midrule
        Oct 25 & Conditional and \newline infinite loops \newline implemented &
        It is important to keep track of loop jumps, otherwise there can be
        infinte loops on execution.\\

        \midrule
        Oct 28 & For style loop \newline implemented &
        Looking at the generated code I can tell there are optimizations that
        can be done, however they are probably not done while generating the
        IR code, since sometimes context is needed to perform such
        \newline optimizations.\\

        \midrule
        Oct 28 & Skip and break \newline implemented &
        Despite having a jump stack and similar structures to handle the
        nesting of conditions and loops, some other structures like queues are
        necesarry to solve this control flow statements.\\

        \midrule
        Nov  6 & Procedures \newline implemented &
        Procedure calls are fairly easy to understand however the details
        required for them to work in a virtual machine are still needed to be
        solved.\\

        \midrule
        Nov  7 & Semantics for \newline expressions \newline implemented &
        Despite having worked on the semantic cube, it was not used since it
        was not a priority. However now that I am seeking to working on the
        memory layout, having this validation will make it much more easy and
        reliable to implement.\\

        \midrule
        Nov  8 & Semantics for \newline procedures \newline implemented &
        The memory mapper is great stategy to create the context independant
        variables for each procedure.\\

        \midrule
        Nov  9 & Parameters \newline semantics \newline implemented &
        Way back to the implementation of the symbol table, I had already
        thought on having information regarding parameter types, thus the
        compiler had almost \newline implemented this check.\\
        
        \midrule
        Nov  9 & Return type \newline semantics \newline implemented &
        Way back to the implementation of the symbol table, I had already
        thought on having information regarding return types, thus the
        compiler had almost \newline implemented this check.\\

        \bottomrule
    \end{tabular}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{cp{1.25in}p{2.5in}}
        \toprule
        \textbf{Date} & \textbf{Title} & \textbf{Observations}\\
        \midrule
        Nov 10 & Variable-Address mapping \newline implemented &
        Implementing the variable-address mapping right on expression
        compilation has the benefit to be more memory efficient, since only
        used variables are included on the memory count.\\

        \midrule
        Nov 11 & \texttt{.quack} file \newline{generation} &
        Once the IR code was generated it was only necessary to append it to
        some instructions to initialize global memory.\\

        \midrule
        Nov 14 & Reading of \texttt{.quack} files and global \newline memory
        \newline initialization &
        The \texttt{.quack} files were change to only be a single line string
        of opcodes and addresses to simplify the reading. This files are meant
        for computer readability, not for humans.\\

        \midrule
        Nov 14 & Era, Goproc, Bool Operators \newline implemented &
        I decided to implement this operators first because they are somewhat
        direct.\\

        \midrule
        Nov 15 & Basic language \newline features \newline implemented &
        The implementation of arithmetic operations on the virtual machine is
        long, boring, and repetitive, but easy. On the other side it is 
        really interesting to see code execution.\\

        \midrule
        Nov 15 & Print implemented &
        Nothing to be said, just the implementation of the print instruction
        on the virtual machine.\\

        \midrule
        Nov 15 & Procedure calls \newline implemented &
        This was a really interesting problem to solve since it involve on the
        implementation of a memory stack to handle procedure calls.\\

        \midrule
        Nov 16 & Procedure fully working in vm &
        I was originally stuck since there was no direct solution for this,
        however, after some thought I was able to implement a parameter buffer
        to then assign the correspondant values on the context of the function.\\

        \bottomrule
    \end{tabular}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{cp{1.25in}p{2.5in}}
        \toprule
        \textbf{Date} & \textbf{Title} & \textbf{Observations}\\
        \midrule
        Nov 19 & Arrays implemented &
        Arrays were perhaps one of the most \emph{``challenging''} features to
        implement, not because of IR code generation, rather the implementation
        of indirection was not clear to do on the virtual machine. However
        after some thought I was able to come with a simple but efective
        solution to the problem.\\ 

        \midrule
        Nov 19 & Tensors \newline implemented &
        $n$-dimensional arrays, or as I call them \emph{tensors}, were actually
        super easy to implement after the experience gained with the
        implementation of arrays.\\

        \midrule
        Nov 20 & Special scalar \newline procedures \newline implemented &
        The implementation of this functions really helps with the user
        experience while using the language, since commonly used functions are
        no longer needed to be implemented on every program and also they are
        more eficient, since they are just a \newline library call.\\

        \midrule
        Nov 21 & Special vectorial \newline procedures \newline implemented &
        Similar to scalar procedures, these were fairly easy to implement. It
        just required rebuilding the vectors inside the virtual machine and
        perform operations.\\

        \midrule
        Nov 22 & Procedure call \newline nesting error \newline message added &
        Throughtout testing I noticed that it was not possible currently to
        handle procedure call nesting. The solution is relatively easy
        (it requires stacks), however due to the remaining time, I decided to
        leave it out of the language for the delivery.\\

        \bottomrule
    \end{tabular}
\end{figure}

\newpage

\subsection{Test cases}

\begin{figure}[H]
    \centering
    \begin{tabular}{cp{2.5in}c}
        \toprule
        \textbf{No.} & \textbf{Description} & \textbf{Status}\\
        \midrule  1 & Support for global variables & Passed \\
        \midrule  2 & Support for numeric data types & Passed \\
        \midrule  3 & Support for conditional statements & Passed \\
        \midrule  4 & Support for loop statements & Passed \\
        \midrule  5 & Support for modules & Passed \\
        \midrule  6 & Support for recursion & Passed \\
        \midrule  7 & Support for structured types & Passed \\
        \midrule  8 & Support for compile-time error & Passed \\
        \midrule  8 & Support for intermidiate code generation & Passed \\
        \midrule  9 & Support for execution of generated code & Passed \\
        \midrule 10 & Support for memory management & Passed \\
        \midrule 11 & Support for run-time errors & Passed \\
        \bottomrule
    \end{tabular}
\end{figure}
