
\chapter{Code Documentation}

\section{General Code Overview}

\paragraph{} The codebase, ommiting \texttt{doc}, \texttt{examples} and
\texttt{vim}, has the following structure.

\begin{verbatim}
(main directory)
  - BigDuck.g4
  - Makefile
  - README.md
  - compiler.go
  - main.go
  - parser*
  - run.go
  - structs
      - enums.go
      - linked_list.go
      - memory.go
      - memory_mapper.go
      - memory_stack.go
      - queue.go
      - semantic_cube.go
      - stack.go
      - stack_pointer.go
      - symbol_table.go
      - tac.go
      - virtual_machine.go
  - tac_gen.go
  - tree_listener.go
\end{verbatim}

\paragraph{Note} The parser directory is generated by ANTLR, thus it will not
be talk about, however all the details for lexical an syntax analizer are there.

\section{Modules Description}

\paragraph{} The order of files is given by their usage on an execution.

\begin{figure}[h]
    \centering
    \begin{tabular}{cp{3in}}
        \toprule
        \textbf{File name} & \textbf{Description}\\

        \midrule main.go &
        Is the starting point of the program, according to the given arguments
        it will determine to run the compiler or the virtual machine using the
        filename given.\\

        \midrule compiler.go &
        Makes an instance of the tree listener and runs the ANTLR
        lexer and parser.\\

        \midrule tree\_listener.go &
        Makes an implementation of the grammar listener interface provided by
        ANTLR, it contains a method for entering and exiting a grammar rule.
        All compilation actions are embedded in this methods.\\

        \midrule tac\_gen &
        For any non-trivial or repetitive action for generation of TAC, there
        is an implementation of methods, for tree\_listener, in this file.\\

        \midrule run.go &
        Parsers the \texttt{.quack} file and builds a TAC array to be given 
        to the virutal machine, and the runs it.\\

        \midrule structs &
        Contains all the data strutures used for compilation and execution. I
        will not go throught each file since they are self explanatory.\\

        \bottomrule
    \end{tabular}
\end{figure}

\newpage

\section{Code excerpts}

\paragraph{} On the following section, there some excerpts of code with
some descriptions.

\subsection{GenerateOpTac}

\begin{verbatim}
func (l *BigDuckListener) GenerateOpTAC(pointer int) {
\end{verbatim}

\paragraph{} The signature of this method is read as a method for a pointer
to a BigDuckListener, this means that there is mutability on the struct. The
pointer int argument indicates if there is an allocation for a new pointer
and which argument of the operation is the pointer.

\begin{verbatim}
    var args [3]string
    var types [3]int
    var i, argc int

    op := l.PopOp()

    is_unary, _ := structs.IsUnaryOp[op]

    if is_unary {
        argc = 0
    } else {
        argc = 1
    }
\end{verbatim}

\paragraph{} Retrieving basic information for TAC generation; operator, 
argument count, if it is a unary operator.

\begin{verbatim}
    for i = argc; i >= 0; i-- {
        item, _ := l.argstack.Pop()
        args[i], _ = item.(string)
        item, _ = l.typestack.Pop()
        types[i], _ = item.(int)
    }
\end{verbatim}

\paragraph{} Getting arguments and types from argstack and typestack.

\newpage

\begin{verbatim}
    if structs.Cube[op][types[0]][types[argc]] == structs.Error_t {
        l.valid = false;
        fmt.Printf("line %d:%d type error mismatch\n", l.curr_line, l.curr_col)
    } else if op != structs.ASG {
        types[2] = structs.Cube[op][types[0]][types[argc]]
        l.typestack.Push(types[2])
    }
\end{verbatim}

\paragraph{} Check with semantic cube, and if operator not assignment (meaning
there is a temporal variable generated) the push the type of the result into
typestack.

\begin{verbatim}

    if op == structs.ASG {
        args[2] = args[0]
        args[0] = args[1]
        args[1] = ""
        types[2] = types[0]
        types[0] = types[1]
        types[1] = 0
    } else {
        args[2] = "t" + strconv.Itoa(l.tmpc)
        l.argstack.Push(args[2])
        l.tmpc++
    }
\end{verbatim}

\paragraph{} Because the target address on assigment is on the retrieved
variables, then it necessary to make some adjusments to the order of the
arguments. Otherwise create a new temporal and push it into argstack.

\newpage

\begin{verbatim}

    var address [3]int

    for i = 0; i < 3; i++ {
        scope, _, exists := l.symtable.Lookup(args[i])

        if exists || (len(args[i]) > 0 && args[i][0] == 't') {
            if i + 1 == pointer {
                l.memmap.RegisterPointer(scope, args[i])
            }

            address[i] = l.memmap.GetAddress(scope, args[i], types[i])

        } else if len(args[i]) > 0 {
            address[i] = l.memmap.GetAddress(structs.Global, args[i], types[i])
        }
    }
\end{verbatim}

\paragraph{} For each argument, test if it is variable or temporal then,
if it matches with pointer allocate the pointer and lastly get its address,
else register as global variable and get address.

\begin{verbatim}
    l.ir_code = append(
        l.ir_code,
        structs.Tac{
            Op: op,
            Args: args,
            Address: address})
    l.pc++
}
\end{verbatim}

\paragraph{} Lastly create a new TAC, append it to the array of TACs, and
increment progam counter.

\newpage

\subsection{Memory management methods}

\begin{verbatim}
func (m *memory) InitGlobal(ic, fc, bc int) {
    m.Strings = make(map[int]string, ic)
    m.MemI[Global] = make([]int, ic)
    m.MemF[Global] = make([]float64, fc)
    m.MemB[Global] = make([]bool, bc)
    m.framesize = make(map[int]int)
    m.Sp = make(map[int]int)
}
\end{verbatim}

\paragraph{} Create slices (Go's name for dynamic arrays) for each global
memory pool per type, and initialize framesizes and stack pointers.

\begin{verbatim}
func (m *memory) InitLocal(ic, fc, bc int) {
    m.MemI[Local] = append(m.MemI[Local], make([]int, ic)...)
    m.MemF[Local] = append(m.MemF[Local], make([]float64, fc)...)
    m.MemB[Local] = append(m.MemB[Local], make([]bool, bc)...)

    m.memstack.Push(ic, fc, bc)
}

\end{verbatim}

\paragraph{} Increment memory pools' capacity and push allocated memory into
memory stack to keep track of memory used in procedure calls.

\begin{verbatim}

func (m *memory) PushContext() {
    m.Sp[Int_t]     += m.framesize[Int_t]
    m.Sp[Float_t]   += m.framesize[Float_t]
    m.Sp[Bool_t]    += m.framesize[Bool_t]

    ic, fc, bc := m.memstack.Top()
    m.framesize[Int_t]      = ic
    m.framesize[Float_t]    = fc
    m.framesize[Bool_t]     = bc
}
\end{verbatim}

\paragraph{} Increment stack pointers by current frame size, and update
framesizes.

\newpage

\begin{verbatim}
func (m *memory) PopContext() {
    ic, fc, bc := m.memstack.Pop()

    m.MemI[Local] = append(
        []int(nil), m.MemI[Local][:len(m.MemI[Local]) - ic]...)
    m.MemF[Local] = append(
        []float64(nil), m.MemF[Local][:len(m.MemF[Local]) - fc]...)
    m.MemB[Local] = append(
        []bool(nil), m.MemB[Local][:len(m.MemB[Local]) - bc]...)

    ic, fc, bc = m.memstack.Top()

    m.framesize[Int_t]      = ic
    m.framesize[Float_t]    = fc
    m.framesize[Bool_t]     = bc

    m.Sp[Int_t]     -= m.framesize[Int_t]
    m.Sp[Float_t]   -= m.framesize[Float_t]
    m.Sp[Bool_t]    -= m.framesize[Bool_t]
}
\end{verbatim}

\paragraph{} Shrink memory pools, and restore framesizes and stack pointers.

