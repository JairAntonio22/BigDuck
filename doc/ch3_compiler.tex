
\chapter{Compiler}

\section{Development Environment}

\paragraph{} The BigDuck compiler will be developed using the Go programming
language. Antlr4 will be used as lexer and parser generator. And it will be
developed on MacOS, any other system support is not considered. Nevertheless
with access to a Go compiler and ANTLR, it should be possible to run the
BigDuck compiler however this has not been tested.

\section{Lexical Analisis}

\subsubsection{Reserved Keywords}
\begin{verbatim}
proc                return              if                  else
loop                break               skip                and
or                  not                 var                 int
float               bool                true                false
\end{verbatim}

\subsubsection{Tokens}
\begin{align*}
	\texttt{DIGIT}
	&\rightarrow\texttt{[0-9]}\\
	\texttt{DIGITS}
	&\rightarrow\texttt{digit+}\\
	\texttt{LETTER}
	&\rightarrow\texttt{[A-Za-z]}\\
	\texttt{SIGN}
	&\rightarrow\texttt{`` - ''}\\
	\texttt{CTE\_INT}
	&\rightarrow\texttt{sign? digits}\\
	\texttt{CTE\_FLOAT}
	&\rightarrow\texttt{sign? digits (\textbackslash.\ digits)?}\\
	\texttt{ID}
	&\rightarrow\texttt{letter (letter | digit | `` \_ '')*}\\
	\texttt{COMMENT}
	&\rightarrow\texttt{`` \#| '' \phantom{}.*? `` |\# '' *}\\
\end{align*}

\section{Syntactical Analisis}
\paragraph{Note} The following grammar is not a one-to-one description of the
grammar used in the compiler, this is because there are addtional rules just to
have some breakpoints on the grammar required for compilation.
\begin{align*}
	\texttt{program}
	\rightarrow&\ \texttt{vars\_decl procs\_decl}\\
	\phantom{0}\\
	\texttt{vars\_decl}
	\rightarrow&\ \texttt{var\_decl var\_decl}\\
            |&\ \epsilon\\
	\texttt{var\_decl}
	\rightarrow&\ \texttt{VAR ID next\_var var\_type `` ; '' next\_var\_decl}\\
	\texttt{next\_var}
	\rightarrow&\ \texttt{`` , '' ID next\_var}\\
            |&\ \epsilon\\
	\texttt{next\_var\_decl}
	\rightarrow&\ \texttt{var\_decl next\_var\_decl}\\
            |&\ \epsilon\\
	\phantom{0}\\
	\texttt{var\_type}
	\rightarrow&\ \texttt{scalar | tensor}\\
	\phantom{0}\\
	\texttt{scalar}
	\rightarrow&\ \texttt{INT | FLOAT | BOOL}\\
	\phantom{0}\\
	\texttt{tensor}
	\rightarrow&\ \texttt{dimension scalar}\\
	\texttt{dimension}
	\rightarrow&\ \texttt{`` [ '' num\_expr `` ] next\_dimension ''}\\
	\texttt{next\_dimension}
	\rightarrow&\ \texttt{dimension next\_dimension}\\
            |&\ \epsilon\\
	\phantom{0}\\
	\texttt{procs\_decl}
	\rightarrow&\ \texttt{proc\_decl procs\_decl}\\
            |&\ \epsilon\\
	\phantom{0}\\
	\texttt{proc\_decl}
	\rightarrow&\ \texttt{PROC ID proc\_args ret\_type local\_decl block}\\
	\phantom{0}\\
	\texttt{proc\_args}
	\rightarrow&\ \texttt{`` ( '' `` ) ''}\\
            |&\ \texttt{`` ( '' ID next\_args scalar next\_types `` ) ''}\\
	\texttt{next\_args}
	\rightarrow&\ \texttt{`` , '' ID next\_args}\\
            |&\ \epsilon\\
	\texttt{next\_types}
	\rightarrow&\ \texttt{`` ; '' ID next\_args scalar next\_types}\\
            |&\ \epsilon\\
\end{align*}

\begin{align*}
	\texttt{ret\_type}
	\rightarrow&\ \texttt{`` -> '' scalar}\\
            |&\ \epsilon\\
	\phantom{0}\\
	\texttt{bool\_expr}
	\rightarrow&\ \texttt{and\_expr next\_bool}\\
	\texttt{next\_bool}
	\rightarrow&\ \texttt{OR bool\_expr}\\
            |&\ \epsilon\\
	\phantom{0}\\
	\texttt{and\_expr}
	\rightarrow&\ \texttt{not\_expr next\_and}\\
	\texttt{next\_and}
	\rightarrow&\ \texttt{AND bool\_expr}\\
            |&\ \epsilon\\
	\phantom{0}\\
	\texttt{not\_expr}
	\rightarrow&\ \texttt{(NOT | } \epsilon \texttt{ ) bool\_term}\\
	\texttt{bool\_term}
	\rightarrow&\ \texttt{`` ( '' bool\_expr `` ) ''}\\
            |&\ \texttt{rel\_expr}\\
            |&\ \texttt{TRUE}\\
            |&\ \texttt{FALSE}\\
            |&\ \texttt{variable}\\
            |&\ \texttt{proc\_call}\\
	\phantom{0}\\
	\texttt{rel\_expr}
	\rightarrow&\ \texttt{num\_expr rel\_op num\_expr}\\
	\texttt{rel\_op}
	\rightarrow&\ \texttt{`` = ''}\\
            |&\ \texttt{`` /= ''}\\
            |&\ \texttt{`` < ''}\\
            |&\ \texttt{`` > ''}\\
            |&\ \texttt{`` >= ''}\\
            |&\ \texttt{`` <= ''}\\
	\phantom{0}\\
	\texttt{num\_expr}
	\rightarrow&\ \texttt{prod\_expr next\_sum}\\
	\texttt{next\_sum}
	\rightarrow&\ \texttt{( `` + '' | `` - '') num\_expr}\\
            |&\ \epsilon\\
	\phantom{0}\\
	\texttt{prod\_expr}
	\rightarrow&\ \texttt{factor next\_prod}\\
	\texttt{next\_prod}
	\rightarrow&\ \texttt{(`` * '' | `` / '') prod\_expr}\\
            |&\ \epsilon\\
\end{align*}

\begin{align*}
	\texttt{factor}
	\rightarrow&\ \texttt{`` ( '' num\_expr `` ) ''}\\
            |&\ \texttt{CTE\_INT}\\
            |&\ \texttt{CTE\_FLOAT}\\
            |&\ \texttt{variable}\\
            |&\ \texttt{proc\_call}\\
	\phantom{0}\\
	\texttt{variable}
            |&\ \texttt{ID (dimension | } \epsilon \texttt{ )}\\
	\phantom{0}\\
	\texttt{proc\_call}
	\rightarrow&\ \texttt{ID `` ( '' (param | } \epsilon \texttt{ ) `` ) ''}\\
	\texttt{param}
	\rightarrow&\ \texttt{param\_term next\_param}\\
	\texttt{param\_term}
	\rightarrow&\ \texttt{bool\_expr}\\
            |&\ \texttt{num\_expr}\\
	\texttt{next\_param}
	\rightarrow&\ \texttt{`` , '' param}\\
	\texttt{block}
	\rightarrow&\ \texttt{`` \{ '' stmts `` \} ''}\\
	\phantom{0}\\
	\texttt{stmts}
	\rightarrow&\ \texttt{stmt stmts}\\
            |&\ \epsilon\\
	\texttt{stmt}
	\rightarrow&\ \texttt{assigment  `` ; ''}\\
            |&\ \texttt{condition}\\
            |&\ \texttt{loop\_stmt}\\
            |&\ \texttt{ctrl\_flow `` ; ''}\\
            |&\ \texttt{ret\_stmt `` ; ''}\\
            |&\ \texttt{proc\_call `` ; ''}\\
	\phantom{0}\\
	\texttt{assignment}
	\rightarrow&\ \texttt{variable `` <- '' (num\_expr | bool\_expr)}\\
	\phantom{0}\\
	\texttt{condition}
	\rightarrow&\ \texttt{IF bool\_expr block (alter | } \epsilon \texttt{ )}\\
	\phantom{0}\\
	\texttt{alter}
	\rightarrow&\ \texttt{IF bool\_expr block (alter | } \epsilon \texttt{ )}\\
	\phantom{0}\\
	\texttt{loop}
	\rightarrow&\ \texttt{LOOP (for\_style | while\_style | infinite) block}\\
	\texttt{for\_style}
	\rightarrow&\ \texttt{
            (assignment | } \epsilon \texttt{ ) 
            `` ; '' bool\_expr `` ; '' assignment }\\
	\texttt{while\_style}
	\rightarrow&\ \texttt{bool\_expr}\\
	\texttt{infinite}
	\rightarrow&\ \epsilon\\
\end{align*}

\section{IR Code and Semantic Analisis}
\subsection{Operation Code}
\paragraph{} For this project the operation code can be considered as an
instruction set, since each of this operation indicates an action to be perform
by the virtual machine in order to achieve some computation. The operator code
names were chosen to be like mnemonics to facilitate some developement tasks.

\begin{figure}[h]
    \centering
    \begin{tabular}{p{1in}p{3in}}
        \toprule
        \textbf{Operator} & \textbf{Description}\\
        \midrule NOP &
        Null operator, mainly used as null value for \newline compilation checks.\\

        \midrule ASG &
        Assignation.\\

        \midrule OR &
        Logical or.\\

        \midrule AND &
        Logical and.\\

        \midrule NOT &
        Logical not.\\

        \midrule EQ &
        Value equality comparison.\\

        \midrule NEQ &
        Value inequality comparison.\\

        \midrule LES &
        Less than comparison.\\

        \midrule GRE &
        Greater than comparison.\\

        \midrule LEQ &
        Less than or equal comparison.\\

        \midrule GEQ &
        Greater than or equal comparison.\\

        \midrule SUB &
        Arithmetic substraction.\\

        \midrule ADD &
        Arithmetic addition.\\

        \midrule DIV &
        Arithmetic division.\\

        \midrule MUL &
        Arithmetic multiplication.\\

        \midrule GOPROC &
        Indicates change to a procedure.\\

        \midrule GOPROC &
        Indicates change to a procedure.\\

        \midrule ERA &
        Indicates the framesizes for new memory to be \newline allocated.\\

        \midrule PARAM &
        Indicates value of the parameter to be passed to a procedure.\\

        \midrule RETURN &
        Indicates the value to be returned by a procedure.\\

        \midrule ENDPROC &
        Clears the procedure context and restores program execution\\

        \bottomrule
    \end{tabular}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{tabular}{p{1in}p{3in}}
        \toprule
        \textbf{Operator} & \textbf{Description}\\
        \midrule ASSERT &
        Run-time check for tensor index correctness.\\

        \midrule PRINT &
        Prints value to STDOUT.\\

        \midrule PRINTLN &
        Prints value and newline char to STDOUT.\\

        \midrule SET &
        Initializes global address with givenn values.\\

        \midrule PROGRAM &
        Indicates program starting point on executable.\\

        \bottomrule
    \end{tabular}
\end{figure}
\subsection{Virtual Addresses}
\subsection{Syntax Diagrams}
\subsection{Semantic and IR Generation Actions}
\subsection{Semantic Consideration Table}

\section{Memory Management}
\subsubsection{Tree listener}
\begin{figure}[h]
    \centering
    \begin{tabular}{p{1in}p{3in}}
        \toprule
        \textbf{Element} & \textbf{Description}\\
        \midrule Filename &
        Keeps the name of the source code to produce the executable.\\

        \midrule Valid &
        Flag to indicate whether an error has been found or not.\\

        \midrule Debug &
        Flag to indicate whether debug mode is toggled.\\

        \midrule Symbol table &
        Table to keep track of the variable symbols and procedures used in
        source code.\\

        \bottomrule
    \end{tabular}\\
\end{figure}
